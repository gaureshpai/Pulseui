{
  "projectName": "Pulse UI",
  "description": "Pulse UI is a mobile-first, open-source, multi-brand design system and component library built with token-first architecture. It uses SCSS modules with CSS variables, design tokens, and supports multiple brands (MedDash, FitCore, LabSync) with light/dark themes.",
  "techStack": {
    "designTokens": "JSON tokens (primitive.json, component.json, brand.json) → CSS variables",
    "styling": "SCSS modules with CSS custom properties and design tokens",
    "components": "React + TypeScript + SCSS modules + Storybook",
    "documentation": "Storybook Docs with MDX",
    "theming": "Multi-brand dynamic theming via CSS variables and design tokens",
    "packaging": "NPM Packages"
  },
  "tokenArchitecture": {
    "levels": {
      "primitive": "Base design tokens (colors, spacing, typography, effects)",
      "component": "Component-specific tokens mapping to primitive tokens",
      "brand": "Brand-specific overrides and theme variations"
    },
    "structure": {
      "tokens": {
        "primitive.json": "Base design tokens (colors, spacing, typography, effects)",
        "component.json": "Component-specific design tokens",
        "brand.json": "Multi-brand theme definitions"
      },
      "cssVariables": {
        "_tokens.scss": "CSS custom properties generated from design tokens",
        "usage": "Components reference CSS variables (var(--color-blue-8))"
      },
      "colors": {
        "primitive": "Blue, red, gray, dark, green, yellow, teal, violet, indigo scales",
        "semantic": "Primary, surface, text, border, success, warning, error",
        "brands": {
          "default": "Blue-based primary colors",
          "medash": "MedTech brand with blue primary + green accent",
          "fitcore": "FitnessTech brand with orange primary + green accent",
          "labsync": "LabSync brand with purple primary + cyan accent"
        }
      },
      "spacing": [
        "xs (4px)",
        "sm (8px)",
        "md (16px)",
        "lg (24px)",
        "xl (32px)",
        "xxl (48px)"
      ],
      "typography": {
        "fontFamily": "Roboto (sans-serif), Roboto Mono (monospace)",
        "fontSizes": [
          "xxs (10px)",
          "xs (12px)",
          "sm (14px)",
          "md (16px)",
          "lg (18px)",
          "xl (20px)"
        ],
        "fontWeights": [
          "normal (400)",
          "medium (500)",
          "semibold (600)",
          "bold (700)"
        ],
        "lineHeights": "Tokenized line heights for each font size"
      },
      "effects": {
        "borderRadius": "xs (2px), sm (4px), md (8px), lg (12px), xl (16px), full (9999px)",
        "boxShadow": "xs, sm, md, lg, xl shadow tokens",
        "zIndex": "dropdown, sticky, fixed, modal-backdrop, modal, popover, tooltip"
      }
    },
    "themes": [
      "default",
      "medash",
      "fitcore",
      "labsync"
    ],
    "modes": [
      "light",
      "dark"
    ]
  },
  "componentStrategy": {
    "styling": {
      "approach": "SCSS modules with CSS custom properties",
      "pattern": "Components use semantic CSS variables (var(--color-blue-8))",
      "benefits": [
        "Design token consistency",
        "Multi-brand support",
        "Theme switching",
        "Type safety with TypeScript",
        "Scoped styling with CSS modules"
      ]
    },
    "platforms": [
      "Web (React + TypeScript)",
      "Mobile (React Native planned)"
    ],
    "statesToInclude": [
      "Default",
      "Hover",
      "Active",
      "Disabled",
      "Loading",
      "Focused",
      "With icon (left/right)",
      "With label",
      "Compact mode",
      "Justification (center/space-between)"
    ],
    "interactionModels": [
      "Keyboard accessible",
      "ARIA compliant",
      "Focus management"
    ],
    "responsiveness": "All components must scale and respond across viewports (mobile-first)",
    "brands": [
      "default",
      "medash",
      "fitcore",
      "labsync"
    ]
  },
  "designSystemArchitecture": {
    "tokenFlow": {
      "1": "Design tokens defined in JSON files",
      "2": "CSS variables generated from tokens",
      "3": "Components consume CSS variables",
      "4": "Brand themes override CSS variables"
    },
    "multiBrandSupport": {
      "approach": "CSS variables with data attributes",
      "implementation": ":root[data-brand='medash'] { --color-blue-8: #1971c2ff; }",
      "benefits": [
        "Zero component changes for new brands",
        "Dynamic theme switching",
        "Consistent component behavior",
        "Easy brand onboarding"
      ]
    },
    "componentPattern": {
      "fileStructure": "ComponentName/ComponentName.tsx + ComponentName.module.scss + ComponentName.stories.tsx + ComponentName.test.tsx",
      "styling": "CSS modules with design token references",
      "props": "Semantic props (variant, size, state) instead of utility classes"
    }
  },
  "figma": {
    "coreSetup": "Figma variables defined for core tokens",
    "componentSets": "Web + Mobile variants using auto layout",
    "namingConvention": "prefix.component.platform.state",
    "variableLibrary": "Used to swap themes/brands via mode tokens"
  },
  "tailwindConfig": {
    "purpose": "Available for rapid prototyping and utility-first styling",
    "integration": "Tailwind config references same design tokens via CSS variables",
    "usage": "Not used for core design system components (uses SCSS modules instead)"
  },
  "storybook": {
    "structure": "Each component must include a doc page with prop table, usage examples, and all states as stories",
    "addonSupport": [
      "Controls",
      "Docs",
      "Accessibility",
      "Themes",
      "Viewport"
    ],
    "folderStructure": "src/components/{component-name}/index.tsx + {component-name}.stories.tsx + {component-name}.test.tsx + {component-name}.docs.mdx"
  },
  "goals": [
    "Design tokens must drive all styling (no hardcoded values)",
    "Each component is accessible, responsive, and multi-brand ready",
    "SCSS modules provide scoped styling and design token integration",
    "Storybook must act as single source of truth for devs and designers",
    "Maintain open-source discipline (naming, structure, docs)",
    "Support multiple brands with consistent component behavior"
  ],
  "keyPrinciples": [
    "Token-first architecture - all values come from design tokens",
    "SCSS modules for component styling with CSS variables",
    "Multi-brand support through CSS variable overrides",
    "Semantic component APIs instead of utility classes",
    "Type safety with TypeScript",
    "Design system governance through centralized tokens"
  ]
}

# Storybook Component Setup Procedure

## Overview
This document outlines the exact procedure for setting up a component in Storybook, based on the established pattern used in the PulseUI design system.

## Component Structure Pattern

Every component follows this file structure:
```
src/components/atoms/[ComponentName]/
├── [ComponentName].tsx          # Main component implementation
├── [ComponentName].stories.tsx   # Storybook stories
├── [ComponentName].docs.mdx      # Component documentation (optional)
├── [ComponentName].test.tsx      # Unit tests
├── [ComponentName].module.scss   # Component styles
├── README.md                     # Component documentation
└── index.ts                      # Export file
```

## Step-by-Step Setup Procedure

### 1. Component Implementation ([ComponentName].tsx)

**Requirements:**
- Use TypeScript with proper interface definition
- Include JSDoc comments for all props
- Use forwardRef for form components
- Implement proper prop types and defaults
- Handle icon components with string mapping

**Template:**
```tsx
import React, { forwardRef } from "react";
import type { SvgIconComponent } from "@mui/icons-material";
import { Icon } from "../Icon/index";
import { /* Import icons from IconSet */ } from "../Icon/IconSet";
import styles from "./[ComponentName].module.scss";

export interface [ComponentName]Props {
  /** Prop description */
  propName?: PropType;
  // ... other props
}

export const [ComponentName] = forwardRef<HTMLElement, [ComponentName]Props>(
  ({ prop1, prop2, ...props }, ref) => {
    // Component implementation
    return (
      <div ref={ref} className={componentClasses}>
        {/* Component content */}
      </div>
    );
  }
);

[ComponentName].displayName = "[ComponentName]";
```

### 2. Storybook Stories ([ComponentName].stories.tsx)

**Required Sections:**

#### A. Meta Configuration
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { [ComponentName] } from "./[ComponentName]";

const meta: Meta<typeof [ComponentName]> = {
  title: "Components/atoms/[ComponentName]",
  component: [ComponentName],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component: `Component description`,
      },
    },
  },
  // ... argTypes and args
};
```

#### B. ArgTypes Configuration
```tsx
argTypes: {
  // Text controls
  placeholder: {
    control: "text",
    description: "Input placeholder text",
  },
  
  // Select controls
  variant: {
    control: { type: "select" },
    options: ["option1", "option2", "option3"],
    description: "Component variant",
  },
  
  // Boolean controls
  disabled: {
    control: "boolean",
    description: "Disabled state",
  },
},
```

#### C. Default Args
```tsx
args: {
  placeholder: "Default placeholder",
  variant: "default",
  disabled: false,
  // ... other default values
},
```

#### D. Story Types
Create these standard stories:

1. **Playground** - Interactive story with controls
2. **Variants** - Show all component variants
3. **Sizes** - Show all component sizes
4. **States** - Show all component states
5. **WithIcons** - Show icon combinations
6. **CompleteShowcase** - Comprehensive overview

**Story Template:**
```tsx
export const [StoryName]: Story = {
  render: () => (
    <div className="space-y-8">
      <div>
        <h3 className="text-lg font-semibold mb-4">Section Title</h3>
        <[ComponentName] prop1="value1" prop2="value2" />
      </div>
    </div>
  ),
  parameters: {
    docs: {
      description: {
        story: "Story description",
      },
    },
  },
};
```

### 3. Component Documentation ([ComponentName].docs.mdx)

**Required Sections:**
- Component description
- Props table with types and descriptions
- Variants documentation
- Sizes documentation
- Best practices (Do's and Don'ts)

**Template:**
```mdx
import { Meta } from "@storybook/blocks";
import { [ComponentName] } from "./[ComponentName]";

<Meta title="Components/atoms/[ComponentName]" component={[ComponentName]} />

Component description...

## Props

| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `propName` | `PropType` | `defaultValue` | Prop description |

## Variants

| Variant | Use Case | Example |
|---------|----------|---------|
| **Variant1** | Use case description | `<[ComponentName] variant="variant1">` |

## Best Practices

### ✅ Do
- Best practice 1
- Best practice 2

### ❌ Don't
- Anti-pattern 1
- Anti-pattern 2
```

### 4. Unit Tests ([ComponentName].test.tsx)

### 4. Unit Tests ([ComponentName].test.tsx)

**Required Test Cases:**
- Default rendering
- All variants
- All sizes
- All states
- Icon handling
- Event handlers
- Accessibility features

**Template:**
```tsx
import { render, screen } from "@testing-library/react";
import { describe, it, expect, vi } from "vitest";
import "@testing-library/jest-dom";
import { [ComponentName] } from "./[ComponentName]";

describe("[ComponentName]", () => {
  it("renders with default props", () => {
    render(<[ComponentName]>Content</[ComponentName]>);
    expect(screen.getByText("Content")).toBeInTheDocument();
  });

  it("renders with different variants", () => {
    const variants = ["variant1", "variant2", "variant3"] as const;
    variants.forEach((variant) => {
      render(<[ComponentName] variant={variant}>Content</[ComponentName]>);
      expect(screen.getByText("Content")).toBeInTheDocument();
    });
  });
});
```

### 5. Styles ([ComponentName].module.scss)

**Requirements:**
- Use CSS modules
- Follow design token naming
- Include all variant styles
- Include all size styles
- Include all state styles

**Template:**
```scss
.componentName {
  // Base styles
}

// Variants
.variant-default { }
.variant-filled { }
.variant-unstyled { }

// Sizes
.size-sm { }
.size-md { }
.size-lg { }

// States
.state-enabled { }
.state-focus { }
.state-disabled { }
.state-error { }
```

### 6. Export File (index.ts)

**Template:**
```tsx
export { [ComponentName] } from "./[ComponentName]";
export type { [ComponentName]Props } from "./[ComponentName]";
```

### 7. README.md

**Required Sections:**
- Component description
- Features list
- Usage examples
- Props documentation
- Variants documentation
- Sizes documentation

## Icon Integration Pattern

### Icon Mapping
```tsx
// Map string values to icon components
const getLeftIcon = () => {
  if (typeof leftIcon === "string") {
    if (leftIcon === "none") {
      return null;
    }
    const iconMap: Record<string, SvgIconComponent> = {
      iconName: IconComponent,
      // ... other icons
    };
    return iconMap[leftIcon] || null;
  }
  return leftIcon;
};
```

### Storybook Icon Controls
```tsx
leftIcon: {
  control: { type: "select" },
  options: ["none", "icon1", "icon2", "icon3"],
  description: "Left icon",
},
```

## Quality Checklist

Before considering a component complete, ensure:

- [ ] Component renders without errors
- [ ] All props are properly typed
- [ ] All variants are implemented and tested
- [ ] All sizes are implemented and tested
- [ ] All states are implemented and tested
- [ ] Icon integration works correctly
- [ ] Storybook stories are comprehensive
- [ ] Documentation is complete and accurate
- [ ] Unit tests cover all scenarios
- [ ] Accessibility features are implemented
- [ ] Design tokens are used consistently
- [ ] Component follows established patterns

## Naming Conventions

- **Files**: PascalCase (e.g., `Button.tsx`)
- **Components**: PascalCase (e.g., `Button`)
- **Props**: camelCase (e.g., `leftIcon`)
- **CSS Classes**: kebab-case (e.g., `button-primary`)
- **Story Titles**: Sentence case (e.g., "Primary Action")
- **Story Names**: PascalCase (e.g., `PrimaryAction`)

## File Organization

```
src/components/atoms/[ComponentName]/
├── [ComponentName].tsx          # Main component (1st priority)
├── [ComponentName].stories.tsx   # Storybook stories (2nd priority)
├── [ComponentName].test.tsx      # Unit tests (3rd priority)
├── [ComponentName].module.scss   # Styles (4th priority)
├── [ComponentName].docs.mdx      # Documentation (5th priority)
├── README.md                     # Component docs (6th priority)
└── index.ts                      # Exports (7th priority)
```

This procedure ensures consistency across all components in the design system and provides a comprehensive development experience.
