#!/usr/bin/env node

/**
 * Simple theme generator from _tokens.scss
 * Focuses on essential color tokens for light/dark themes
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Paths
const TOKENS_SCSS_PATH = path.join(__dirname, "../src/styles/_tokens.scss");
const THEMES_TS_PATH = path.join(__dirname, "../src/styles/themes.ts");

// Simple token extraction - focus on color scales
function extractColorTokens(scssContent) {
  const tokens = {
    colors: {},
    spacing: {},
    typography: {},
    borderRadius: {},
    shadows: {},
  };

  // Extract color scales (e.g., --color-blue-6: #228be6;)
  const colorScaleRegex = /--color-([a-z]+)-(\d+):\s*([^;]+);/g;
  let match;

  while ((match = colorScaleRegex.exec(scssContent)) !== null) {
    const [, colorName, shade, value] = match;
    const cleanValue = value.trim();

    // Skip CSS variable references
    if (cleanValue.startsWith("var(")) continue;

    if (!tokens.colors[colorName]) {
      tokens.colors[colorName] = {};
    }
    tokens.colors[colorName][shade] = cleanValue;
  }

  // Extract single colors (e.g., --color-white: #ffffff;)
  const singleColorRegex = /--color-([a-z]+):\s*([^;]+);/g;
  while ((match = singleColorRegex.exec(scssContent)) !== null) {
    const [, colorName, value] = match;
    const cleanValue = value.trim();

    // Skip CSS variable references
    if (cleanValue.startsWith("var(")) continue;

    // Only add if it's not already in colors (avoid duplicates)
    if (!tokens.colors[colorName]) {
      tokens.colors[colorName] = cleanValue;
    }
  }

  // Add some basic spacing and typography
  tokens.spacing = {
    0: "0px",
    1: "4px",
    2: "8px",
    3: "12px",
    4: "16px",
    5: "20px",
    6: "24px",
    7: "28px",
    8: "32px",
    9: "36px",
    10: "40px",
    12: "48px",
    16: "64px",
    20: "80px",
    24: "96px",
    32: "128px",
    40: "160px",
    48: "192px",
    56: "224px",
    64: "256px",
  };

  tokens.typography = {
    h1: { fontSize: "2.25rem", lineHeight: "2.5rem", fontWeight: "700" },
    h2: { fontSize: "1.875rem", lineHeight: "2.25rem", fontWeight: "600" },
    h3: { fontSize: "1.5rem", lineHeight: "2rem", fontWeight: "600" },
    h4: { fontSize: "1.25rem", lineHeight: "1.75rem", fontWeight: "600" },
    h5: { fontSize: "1.125rem", lineHeight: "1.75rem", fontWeight: "600" },
    h6: { fontSize: "1rem", lineHeight: "1.5rem", fontWeight: "600" },
    body: { fontSize: "1rem", lineHeight: "1.5rem", fontWeight: "400" },
    bodyLarge: {
      fontSize: "1.125rem",
      lineHeight: "1.75rem",
      fontWeight: "400",
    },
    bodySmall: {
      fontSize: "0.875rem",
      lineHeight: "1.25rem",
      fontWeight: "400",
    },
    caption: { fontSize: "0.75rem", lineHeight: "1rem", fontWeight: "400" },
  };

  tokens.borderRadius = {
    none: "0px",
    sm: "2px",
    md: "4px",
    lg: "8px",
    xl: "12px",
    "2xl": "16px",
    "3xl": "24px",
    full: "9999px",
  };

  tokens.shadows = {
    none: "none",
    sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
    md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
    lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
    xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
    "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
  };

  return tokens;
}

// Generate dark theme
function generateDarkTheme(lightTokens) {
  const darkTokens = JSON.parse(JSON.stringify(lightTokens));

  // Invert color scales for dark theme
  Object.keys(darkTokens.colors).forEach((colorName) => {
    if (typeof darkTokens.colors[colorName] === "object") {
      const shades = Object.keys(darkTokens.colors[colorName]);
      const invertedShades = [...shades].reverse();

      shades.forEach((shade, index) => {
        darkTokens.colors[colorName][shade] =
          lightTokens.colors[colorName][invertedShades[index]];
      });
    }
  });

  // Override specific colors for dark theme
  darkTokens.colors.background = "#0f172a";
  darkTokens.colors.surface = "#0f172a";
  darkTokens.colors["surface-secondary"] = "#1e293b";
  darkTokens.colors["surface-tertiary"] = "#334155";
  darkTokens.colors["text-primary"] = "#f8fafc";
  darkTokens.colors["text-secondary"] = "#cbd5e1";
  darkTokens.colors["text-muted"] = "#64748b";
  darkTokens.colors["text-disabled"] = "#94a3b8";
  darkTokens.colors["border-primary"] = "#475569";
  darkTokens.colors["border-secondary"] = "#334155";

  return darkTokens;
}

// Generate themes.ts content
function generateThemesTs(lightTokens, darkTokens) {
  return `// Auto-generated themes from _tokens.scss
// This file is generated by scripts/generate-themes.js
// Do not edit manually - changes will be overwritten

import type { Theme } from "./stylesApi";

// Light Theme (generated from _tokens.scss)
export const defaultLightTheme: Theme = ${JSON.stringify(lightTokens, null, 2)};

// Dark Theme (generated from light theme with inversions)
export const defaultDarkTheme: Theme = ${JSON.stringify(darkTokens, null, 2)};

// Export the current default theme (for backward compatibility)
export const defaultTheme = defaultLightTheme;

// Theme types
export type ThemeMode = "light" | "dark";
export type ThemeName = "default-light" | "default-dark";

// Theme mapping
export const themes: Record<ThemeName, Theme> = {
  "default-light": defaultLightTheme,
  "default-dark": defaultDarkTheme,
};
`;
}

// Main execution
function main() {
  try {
    console.log("üîÑ Generating themes from _tokens.scss...");

    // Read tokens.scss
    const scssContent = fs.readFileSync(TOKENS_SCSS_PATH, "utf8");
    console.log("üìñ Read SCSS content, length:", scssContent.length);

    // Extract tokens
    const lightTokens = extractColorTokens(scssContent);
    console.log(
      "üé® Extracted color categories:",
      Object.keys(lightTokens.colors)
    );

    // Generate dark theme
    const darkTokens = generateDarkTheme(lightTokens);
    console.log("üåô Generated dark theme");

    // Generate themes.ts content
    const themesContent = generateThemesTs(lightTokens, darkTokens);

    // Write themes.ts file
    fs.writeFileSync(THEMES_TS_PATH, themesContent, "utf8");
    console.log("‚úÖ themes.ts generated successfully!");
    console.log(`üìÅ Location: ${THEMES_TS_PATH}`);

    // Log stats
    const lightColorCount = Object.keys(lightTokens.colors).length;
    console.log(`üé® Light theme colors: ${lightColorCount}`);
    console.log(`üåô Dark theme colors: ${lightColorCount}`);
  } catch (error) {
    console.error("‚ùå Error:", error.message);
    process.exit(1);
  }
}

// Run if called directly
if (process.argv[1] && process.argv[1].endsWith("generate-themes.js")) {
  main();
}

export { main, extractColorTokens, generateDarkTheme };
